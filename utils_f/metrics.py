# AUTOGENERATED! DO NOT EDIT! File to edit: ../metrics.ipynb.

# %% auto 0
__all__ = ['device', 'calculate_r_precision', 'get_r_precision', 'get_all_r_precision']

# %% ../metrics.ipynb 1
import torch

# %% ../metrics.ipynb 3
device = "cuda:0" if torch.cuda.is_available() else "cpu"
device

# %% ../metrics.ipynb 7
def calculate_r_precision(top_r, lbls_data, lbls_trgt):

    r = top_r.shape[1]
    num_trgt = len(top_r)
    
    lbls = [ [lbls_trgt[i], lbls_data[idxs]] for i, idxs in enumerate(top_r)]
    
    corrects = [(lbl_t == lbls_d).sum().item() for lbl_t, lbls_d in lbls]
    return sum(corrects) / (r * num_trgt)


def get_r_precision(r, idxs_li, lbls_data_li, lbls_trgt_li):

    top_r_li = [idxs[:, :r] for idxs in idxs_li]

    return [calculate_r_precision(top_r, lbls_data, lbls_trgt)
            for top_r, lbls_data, lbls_trgt in zip(top_r_li, lbls_data_li, lbls_trgt_li)]


def get_all_r_precision(r_li, idxs_li, lbls_data_li, lbls_trgt_li, transpose= True):

    r_precision_li = torch.tensor([get_r_precision(r, idxs_li, lbls_data_li, lbls_trgt_li) for r in r_li])
    
    if transpose: r_precision_li = r_precision_li.T  
    return r_precision_li
